using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace ITI.TypeScriptDtoGenerator
{
    internal static class DtoGenerator
    {
        public static void GenerateDto(Type type, string outputPath)
        {
            var interfaceBuilder = new StringBuilder();
            var toImport = new List<Type>();

            var extendsClause = "";
            if(type.BaseType != null && type.BaseType.Name != "Object")
            {
                var baseType = MapType(type.BaseType, toImport);
                extendsClause += $" extends {baseType}";
            }

            interfaceBuilder.AppendLine($"export interface {type.Name}{extendsClause} {{");

            foreach (var property in type.GetProperties(BindingFlags.Public | BindingFlags.DeclaredOnly | BindingFlags.Instance))
            {
                var propertyName = MapPropertyName(property.Name);
                var propertyType = MapType(property.PropertyType, toImport);
                interfaceBuilder.AppendLine($"    {propertyName}: {propertyType}");
            }

            interfaceBuilder.AppendLine($"}}");

            var output = new StringBuilder();
            output.AppendLine(Util.AutoGeneratedMessage);
            output.Append(GenerateImports(toImport));
            output.AppendLine();
            output.Append(interfaceBuilder);

            var filePath = Path.Combine(outputPath, $"{type.Name}.ts");
            File.WriteAllText(filePath, output.ToString());
        }

        private static string GenerateImports(List<Type> toImport)
        {
            var typeNamesToImport = toImport.Select(t => t.Name).ToHashSet();
            var output = new StringBuilder();

            foreach(var typeName in typeNamesToImport.OrderBy(n => n))
            {
                output.AppendLine($"import {{ {typeName} }} from './{typeName}'");
            }

            return output.ToString();
        }

        private static string MapPropertyName(string name)
        {
            return char.ToLowerInvariant(name[0]) + name.Substring(1);
        }

        public static string MapType(Type type, List<Type> toImport)
        {
            var typeName = type.Name;

            var rewrites = new Dictionary<string, string>
            {
                ["String"] = "string",
                ["Boolean"] = "boolean",
                ["Int32"] = "number",
                ["Int64"] = "number",
                ["Float"] = "number",
                ["Double"] = "number",
                ["DateTime"] = "string",
                ["DateTimeOffset"] = "string",
                ["Guid"] = "string"
            };

            if (rewrites.ContainsKey(typeName))
            {
                typeName = rewrites[typeName];
            }

            if (type.FullName != null && type.FullName.Contains("System.Collections.Generic.List"))
            {
                var genericArgumentTypeName = MapType(type.GetGenericArguments().Single(), toImport);
                typeName = genericArgumentTypeName + "[]";
            }
            else if (type.Name.Contains("Nullable"))
            {
                var genericArgumentTypeName = MapType(type.GetGenericArguments().Single(), toImport);
                typeName = genericArgumentTypeName + " | null | undefined";
            }
            else if (type.IsGenericType)
            {
                var genericArgumentNames = type.GetGenericArguments().Select(t => MapType(t, toImport));

                typeName = typeName.Split('`')[0];
                typeName += "<" + string.Join(", ", genericArgumentNames) + ">";
            } 
            else
            {
                if(typeName != "number" && typeName != "string" && typeName != "boolean")
                {
                    toImport.Add(type);
                }
            }

            return typeName;
        }
    }
}
