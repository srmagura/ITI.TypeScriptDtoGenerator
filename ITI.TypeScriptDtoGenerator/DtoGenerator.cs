using System.Reflection;
using System.Text;
using Namotion.Reflection;

namespace ITI.TypeScriptDtoGenerator;

internal static class DtoGenerator
{
    public static void GenerateDtos(
        List<Type> dtoTypes,
        List<Type> couldImportTypes,
        string? imports,
        string outputPath
    )
    {
        foreach (var type in dtoTypes)
        {
            var otherDtoTypes = dtoTypes.Where(t => t != type).ToList();
            var couldImportTypes2 = otherDtoTypes.Concat(couldImportTypes).ToList();

            GenerateDto(type, couldImportTypes2, imports, outputPath);
        }
    }

    public static void GenerateDto(Type type, List<Type> couldImportTypes, string? imports, string outputPath)
    {
        var dtoString = GenerateDtoToString(type, couldImportTypes, imports);

        var filePath = Path.Combine(outputPath, $"{GetExtensionlessTypeScriptFilename(type)}.ts");
        File.WriteAllText(filePath, dtoString);
    }

    internal static string GetExtensionlessTypeScriptFilename(Type type)
    {
        if (!type.IsGenericTypeDefinition && !type.IsGenericType) return type.Name;

        return type.Name.Split('`')[0];
    }

    internal static string GetTypeScriptTypeName(Type type)
    {
        if (!type.IsGenericTypeDefinition) return type.Name;

        return $"{type.Name.Split('`')[0]}<{string.Join(",", type.GetGenericArguments().Select(a => a.Name))}>";
    }

    internal static string GenerateDtoToString(Type type, List<Type> couldImportTypes, string? imports)
    {
        var interfaceBuilder = new StringBuilder();
        var unknownTypes = new List<Type>();

        var extendsClause = "";
        if (type.BaseType != null && type.BaseType.Name != "Object")
        {
            var baseType = MapType(type.BaseType.ToContextualType(), unknownTypes);
            extendsClause += $" extends {baseType}";
        }

        interfaceBuilder.AppendLine($"export interface {GetTypeScriptTypeName(type)}{extendsClause} {{");

        foreach (var property in type.GetProperties(BindingFlags.Public | BindingFlags.DeclaredOnly | BindingFlags.Instance))
        {
            var propertyName = MapPropertyName(property.Name);
            var propertyType = MapType(property.ToContextualProperty().PropertyType, unknownTypes);

            interfaceBuilder.AppendLine($"    {propertyName}: {propertyType}");
        }

        interfaceBuilder.AppendLine($"}}");

        var output = new StringBuilder();
        output.AppendLine(Util.AutoGeneratedMessage);

        if (imports != null)
            output.Append(imports);

        output.Append(GenerateImports(couldImportTypes, unknownTypes));
        output.AppendLine();
        output.Append(interfaceBuilder);
        Util.ConvertLineEndings(output);

        return output.ToString();
    }

    private static string GenerateImports(List<Type> couldImportTypes, List<Type> unknownTypes)
    {
        var couldImportTypeNames = couldImportTypes.Select(GetExtensionlessTypeScriptFilename).ToHashSet();
        var unknownTypeNames = unknownTypes.Select(GetExtensionlessTypeScriptFilename).ToHashSet();
        var typeNamesToImport = unknownTypeNames.Intersect(couldImportTypeNames);

        var output = new StringBuilder();

        foreach (var typeName in typeNamesToImport.OrderBy(n => n))
        {
            output.AppendLine($"import {{ {typeName} }} from './{typeName}'");
        }

        return output.ToString();
    }

    // Adapted from Newtonsoft.Json StringUtils.cs
    private static string ToCamelCase(string s)
    {
        if (string.IsNullOrEmpty(s) || !char.IsUpper(s[0]))
        {
            return s;
        }

        char[] chars = s.ToCharArray();

        for (int i = 0; i < chars.Length; i++)
        {
            if (i == 1 && !char.IsUpper(chars[i]))
            {
                break;
            }

            bool hasNext = i + 1 < chars.Length;
            if (i > 0 && hasNext && !char.IsUpper(chars[i + 1]))
            {
                // if the next character is a space, which is not considered uppercase
                // (otherwise we wouldn't be here...)
                // we want to ensure that the following:
                // 'FOO bar' is rewritten as 'foo bar', and not as 'foO bar'
                // The code was written in such a way that the first word in uppercase
                // ends when if finds an uppercase letter followed by a lowercase letter.
                // now a ' ' (space, (char)32) is considered not upper
                // but in that case we still want our current character to become lowercase
                if (char.IsSeparator(chars[i + 1]))
                {
                    chars[i] = char.ToLowerInvariant(chars[i]);
                }

                break;
            }

            chars[i] = char.ToLowerInvariant(chars[i]);
        }

        return new string(chars);
    }

    private static string MapPropertyName(string name)
    {
        return ToCamelCase(name);
    }

    internal static string MapType(ContextualType contextualType, List<Type> unknownTypes)
    {
        var type = contextualType.Type;
        var typeName = contextualType.Type.Name;

        var rewrites = new Dictionary<string, string>
        {
            ["String"] = "string",
            ["Boolean"] = "boolean",
            ["Int32"] = "number",
            ["Int64"] = "number",
            ["Float"] = "number",
            ["Single"] = "number",
            ["Double"] = "number",
            ["Decimal"] = "number",
            ["DateTime"] = "string",
            ["DateTimeOffset"] = "string",
            ["TimeSpan"] = "string",
            ["Guid"] = "string"
        };

        if (rewrites.ContainsKey(typeName))
        {
            typeName = rewrites[typeName];
        }
        else if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(List<>))
        {
            typeName = MapEnumerable(contextualType.GenericArguments.Single(), unknownTypes);
        }
        else if (type.BaseType?.FullName == "System.Array")
        {
            var elementType = type.GetElementType();
            if (elementType == null)
                throw new Exception($"Could not determine element type for {type.FullName}.");

            typeName = MapEnumerable(elementType.ToContextualType(), unknownTypes);
        }
        else if (type.IsGenericType)
        {
            var genericArgumentNames = contextualType.GenericArguments.Select(t => MapType(t, unknownTypes));

            typeName = typeName.Split('`')[0];
            typeName += "<" + string.Join(", ", genericArgumentNames) + ">";

            unknownTypes.Add(type);
        }
        else if (!type.IsGenericParameter)
        {
            unknownTypes.Add(type);
        }

        if (contextualType.Nullability == Nullability.Nullable)
            typeName += " | null | undefined";

        return typeName;
    }

    private static string MapEnumerable(ContextualType elementType, List<Type> unknownTypes)
    {
        var elementTypeName = MapType(elementType, unknownTypes);

        if (elementTypeName.Contains(' '))
        {
            return $"({elementTypeName})[]";
        }
        else
        {
            return elementTypeName + "[]";
        }
    }
}
